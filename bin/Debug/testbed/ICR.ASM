ÓICR   °°°±° ;	ICR FutureSoft°°°²° ;	11/19/81°°°³° 	ORG	0FEE8H°°°´° ;  read a disk sector°°°µ° ;  sector number passed in USR call from basic°°°¶° USR0	CALL	0A7FH°°°·° 	DI°°°¸° 	LD	E,L		;L = sector number°°°¹° 	LD	D,0		;force track 0°°±°° 	CALL	READ		;read the sector°°±±° 	EI°°±²° 	AND	9CH°°±³° 	LD	(0FFFFH),A°°±´° 	LD	HL,-1°°±µ° 	JP	Z,0A9AH°°±¶° 	INC	HL°°±·° 	JP	0A9AH°°±¸° READ	LD	A,(4)		;read ROM for model°°±¹° 	CP	30H°°²°° 	JP	Z,DOMODIII	;go if Z°°²±° 	LD	HL,37ECH°°²²° 	LD	(HL),0FEH°°²³° 	LD	(HL),0D0H°°²´° 	CALL	RESTORE1	;check if drive in system°°²µ° 	RET	NZ		;not in system°°²¶° 	LD	(37EEH),DE	;pass track/sector°°²·° 	XOR	A°°²¸° 	LD	(37EDH),A°°²¹° 	LD	DE,37EFH	;transfer address°°³°° 	LD	BC,0		;load into ROM°°³±° 	CALL	SELECT1°°³²° 	LD	(HL),88H	;read command°°³³° 	CALL	DSKSLO		;wait for valid status°°³´° 	JR	RD11		;transfer data°°³µ° RD12	RRCA			;check for command done°°³¶° 	JR	NC,RD13		;done if bit 0 off°°³·° RD11	LD	A,(HL)		;get status byte°°³¸° 	BIT	1,A		;byte ready ?°°³¹° 	JR	Z,RD12		;check command done°°´°° 	LD	A,(DE)		;fetch a byte°°´±° 	LD	(BC),A°°´²° 	INC	BC°°´³° 	JR	RD11		;check for next°°´´° RD13	LD	A,(HL)		;read result°°´µ° 	RET			;done°°´¶° DELAY	PUSH	BC		;one second delay°°´·° 	LD	BC,0°°´¸° 	CALL	60H°°´¹° 	POP	BC°°µ°° 	RET°°µ±° DSKSLO	PUSH	BC		;short delay to wait°°µ²° 	LD	B,12		;for valid FDC status°°µ³° 	DJNZ	$°°µ´° 	POP	BC°°µµ° 	RET°°µ¶° SELECT1	LD	A,(HL)		;read current status°°µ·° 	AND	80H°°µ¸° 	LD	A,2		;use drive two°°µ¹° 	LD	(37E1H),A	;turn it on°°¶°° 	RET	Z		;return if already on°°¶±° 	CALL	DELAY°°¶²° 	LD	A,(HL)		;test again°°¶³° 	AND	80H°°¶´° 	RET			;return with flag set°°¶µ° RESTORE1	CALL	SELECT1	;turn on drive°°¶¶° 	RET	NZ		;not available°°¶·° 	LD	(HL),0BH	;restore to track 0°°¶¸° 	CALL	DSKSLO		;short delay°°¶¹° RESWAIT1	LD	A,(HL)	;check status°°·°° 	BIT	0,A		;done yet ?°°·±° 	JR	NZ,RESWAIT1	;wait if not°°·²° 	CPL			;bit 2 MUST be set°°·³° 	AND	4°°·´° 	RET°°·µ° DOMODIII	CALL	RESTORE3°°·¶° 	RET	NZ°°··° 	LD	A,D°°·¸° 	OUT	(0F1H),A°°·¹° 	OUT	(0F3H),A°°¸°° 	LD	A,E°°¸±° 	OUT	(0F2H),A°°¸²° 	LD	A,(4049H)	;get NMI vector°°¸³° 	LD	(NMI1),A	;save this°°¸´° 	LD	A,0C3H		;put in JUMP vector°°¸µ° 	LD	(4049H),A°°¸¶° 	LD	HL,(404AH)	;get address°°¸·° 	LD	(NMI2),HL	;save too°°¸¸° 	LD	HL,NMIRET	;our NMI vector°°¸¹° 	LD	(404AH),HL°°¹°° 	LD	HL,0		;load into ROM°°¹±° 	LD	DE,0C202H	;select and mask bytes°°¹²° 	LD	BC,0F3H		;count and register°°¹³° 	LD	A,80H		;issue command°°¹´° 	OUT	(0F0H),A	;to FDC°°¹µ° 	CALL	DSKSLO		;short wait°°¹¶° 	DI			;disable°°¹·° 	LD	A,0C0H		;allow NMI return°°¹¸° 	OUT	(0E4H),A°°¹¹° RD31	IN	A,(0F0H)	;check status°±°°° 	AND	E		;check bit 1°±°±° 	JR	Z,RD31		;wait if not ready°±°²° 	INI			;read in the byte°±°³° 	LD	A,D		;get select mask°±°´° RD32	OUT	(0F4H),A	;put CPU into WAIT states°±°µ° 	INI			;while it transfers data°±°¶° 	JR	RD32		;wait here till interrupt°±°·° NMIRET	POP	HL		;restore the stack°±°¸° 	XOR	A		;turn off NMI°±°¹° 	OUT	(0E4H),A°±±°° 	LD	A,0		;get old NMI vector°±±±° NMI1	EQU	$-1°±±²° 	LD	(4049H),A°±±³° 	LD	HL,0°±±´° NMI2	EQU	$-2°±±µ° 	LD	(404AH),A°±±¶° 	CALL	DSKSLO°±±·° 	IN	A,(0F0H)	;check result°±±¸° 	RET°±±¹° SELECT3	IN	A,(0F0H)	;read staus°±²°° 	AND	80H°±²±° 	LD	A,82H		;drive bit mask°±²²° 	OUT	(0F4H),A	;turn it on°±²³° 	RET	Z		;done if already on°±²´° 	CALL	DELAY°±²µ° 	IN	A,(0F0H)°±²¶° 	AND	80H°±²·° 	RET°±²¸° RESTORE3	CALL	SELECT3°±²¹° 	RET	NZ°±³°° 	LD	A,0BH°±³±° 	OUT	(0F0H),A°±³²° 	CALL	DSKSLO°±³³° RESWAIT3	IN	A,(0F0H)°±³´° 	BIT	0,A°±³µ° 	JR	NZ,RESWAIT3°±³¶° 	CPL°±³·° 	AND	4°±³¸° 	RET°±³¹° DEAD	LD	HL,3C00H	;start of RAM°±´°° 	LD	DE,3C01H°±´±° 	LD	BC,0		;do all 64K°±´²° 	LD	(HL),'?'	;with HUH?°±´³° 	LDIR			;done°±´´° 	HALT			;just in case°±´µ° 	END	A,(0F0H)°±³´° 	BIT	0,A°±³µ° 	JR	NZ